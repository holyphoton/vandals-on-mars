const WebSocket = require('ws');
const server = new WebSocket.Server({ port: 8090 });
const fs = require('fs');
const path = require('path');

// Game configuration
const CONFIG = {
  world: {
    radius: 100,
    terrainSeed: 42424242, // Fixed seed for consistent terrain
  }
};

// Store all billboards to send to new players
const billboards = [];

// Generate and store terrain data
let terrainData = null;

// Try to load saved terrain data or generate new
function initializeTerrainData() {
  const terrainFilePath = path.join(__dirname, 'terrain-data.json');
  
  try {
    // Check if terrain data file already exists
    if (fs.existsSync(terrainFilePath)) {
      console.log('Loading terrain data from file');
      const fileData = fs.readFileSync(terrainFilePath, 'utf8');
      terrainData = JSON.parse(fileData);
      console.log(`Loaded terrain data: ${terrainData.craters.length} craters, ${terrainData.rocks.length} rocks, ${terrainData.towers.length || 0} towers`);
    } else {
      console.log('No terrain data file found, will generate terrain on first request');
    }
  } catch (error) {
    console.error('Error loading terrain data:', error);
    console.log('Will generate terrain on first request');
  }
}

// Initialize terrain data at server startup
initializeTerrainData();

// Log server startup
console.log('WebSocket server running on port 8090');
console.log(`Terrain seed: ${CONFIG.world.terrainSeed}`);

server.on('connection', (socket) => {
  console.log('Player connected');

  socket.on('message', (message) => {
    try {
      const data = JSON.parse(message);
      console.log('Received message type:', data.type);

      // Handle different message types
      if (data.type === 'billboard_data') {
        // Store billboard data for future players
        const existingIndex = billboards.findIndex(b => b.id === data.id);
        if (existingIndex !== -1) {
          // Update existing billboard but preserve original text and owner
          const originalText = billboards[existingIndex].text;
          const originalOwner = billboards[existingIndex].owner;
          
          billboards[existingIndex] = {
            ...billboards[existingIndex],
            ...data,
            // Keep original text and owner
            text: originalText,
            owner: originalOwner
          };
          
          console.log(`Updated billboard ${data.id} in server storage (preserved text and owner)`);
        } else {
          // Add new billboard
          billboards.push(data);
          console.log(`Added new billboard ${data.id} to server storage`);
        }
        
        // Broadcast the billboard update to all other clients with consistent naming
        const broadcastData = {
          type: 'billboard_data',
          ...data
        };
        
        server.clients.forEach(client => {
          if (client !== socket && client.readyState === WebSocket.OPEN) {
            client.send(JSON.stringify(broadcastData));
          }
        });
      } 
      else if (data.type === 'billboard_remove') {
        // Remove billboard from stored list
        const index = billboards.findIndex(b => b.id === data.id);
        if (index !== -1) {
          billboards.splice(index, 1);
          console.log(`Removed billboard ${data.id} from server storage`);
          
          // Broadcast removal to all other clients with the expected "billboard_removed" type
          const removalData = {
            type: 'billboard_removed',  // Note: Changed from 'billboard_remove' to 'billboard_removed'
            id: data.id,
            timestamp: Date.now()
          };
          
          server.clients.forEach(client => {
            if (client !== socket && client.readyState === WebSocket.OPEN) {
              client.send(JSON.stringify(removalData));
            }
          });
        }
      }
      else if (data.type === 'request_billboards') {
        // Send all stored billboards to the requesting client
        const response = {
          type: 'all_billboards',
          billboards: billboards
        };
        socket.send(JSON.stringify(response));
        console.log(`Sent ${billboards.length} billboards to requesting client`);
      }
      else if (data.type === 'request_terrain_data') {
        // If we don't have terrain data yet, this would be generated by the first player
        // In a production environment, you'd want to pre-generate this during server startup
        if (!terrainData) {
          console.log('No terrain data exists yet - server would request generation from client');
          // In a real implementation, you would generate the terrain here
          // or already have it generated at server start
          
          // For demo purposes, create dummy data that will be populated by first client
          terrainData = {
            seed: CONFIG.world.terrainSeed,
            craters: [],
            rocks: [],
            towers: []
          };
        }
        
        // Send terrain data to the requesting client
        const response = {
          type: 'terrain_data',
          terrainData: terrainData
        };
        socket.send(JSON.stringify(response));
        console.log('Sent terrain data to requesting client');
      }
      else if (data.type === 'terrain_data_update') {
        // First client is providing generated terrain data to the server
        if (data.terrainData && (!terrainData || terrainData.craters.length === 0)) {
          console.log('Received terrain data from client - saving for future clients');
          terrainData = data.terrainData;
          
          // Save to file for persistence
          try {
            fs.writeFileSync(
              path.join(__dirname, 'terrain-data.json'), 
              JSON.stringify(terrainData, null, 2),
              'utf8'
            );
            console.log('Terrain data saved to file');
          } catch (error) {
            console.error('Error saving terrain data:', error);
          }
        }
      }

      // Broadcast the general message to all other clients for other message types
      // But don't broadcast billboard data or removals that are already handled above
      if (data.type !== 'billboard_data' && data.type !== 'billboard_remove') {
        server.clients.forEach(client => {
          if (client !== socket && client.readyState === WebSocket.OPEN) {
            // Ensure we're sending a string, not a raw message object
            if (typeof message === 'string') {
              client.send(message);
            } else {
              // If it's not a string (perhaps an object), stringify it
              try {
                client.send(JSON.stringify(message));
              } catch (error) {
                console.error('Error stringifying message for broadcast:', error);
              }
            }
          }
        });
      }
    } catch (error) {
      console.error('Error processing message:', error);
    }
  });

  socket.on('close', () => {
    console.log('Player disconnected');
  });
});